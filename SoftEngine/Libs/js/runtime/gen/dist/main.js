(()=>{"use strict";var t={d:(s,i)=>{for(var h in i)t.o(i,h)&&!t.o(s,h)&&Object.defineProperty(s,h,{enumerable:!0,get:i[h]})},o:(t,s)=>Object.prototype.hasOwnProperty.call(t,s),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},s={};t.r(s),t.d(s,{Matrix3:()=>z,Matrix4:()=>o,Quaternion:()=>e,Vector2:()=>_,Vector3:()=>r,Vector4:()=>d});const i=[];for(let t=0;t<256;t++)i[t]=(t<16?"0":"")+t.toString(16);function h(t,s,i){return Math.max(s,Math.min(i,t))}Math.PI,Math.PI;class e{constructor(t=0,s=0,i=0,h=1){this._x=t,this._y=s,this._z=i,this._w=h}static slerp(t,s,i,h){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,s,h)}static slerpFlat(t,s,i,h,e,r,n){let a=i[h+0],o=i[h+1],l=i[h+2],u=i[h+3];const y=e[r+0],c=e[r+1],x=e[r+2],m=e[r+3];if(0===n)return t[s+0]=a,t[s+1]=o,t[s+2]=l,void(t[s+3]=u);if(1===n)return t[s+0]=y,t[s+1]=c,t[s+2]=x,void(t[s+3]=m);if(u!==m||a!==y||o!==c||l!==x){let t=1-n;const s=a*y+o*c+l*x+u*m,i=s>=0?1:-1,h=1-s*s;if(h>Number.EPSILON){const e=Math.sqrt(h),r=Math.atan2(e,s*i);t=Math.sin(t*r)/e,n=Math.sin(n*r)/e}const e=n*i;if(a=a*t+y*e,o=o*t+c*e,l=l*t+x*e,u=u*t+m*e,t===1-n){const t=1/Math.sqrt(a*a+o*o+l*l+u*u);a*=t,o*=t,l*=t,u*=t}}t[s]=a,t[s+1]=o,t[s+2]=l,t[s+3]=u}static multiplyQuaternionsFlat(t,s,i,h,e,r){const n=i[h],a=i[h+1],o=i[h+2],l=i[h+3],u=e[r],y=e[r+1],c=e[r+2],x=e[r+3];return t[s]=n*x+l*u+a*c-o*y,t[s+1]=a*x+l*y+o*u-n*c,t[s+2]=o*x+l*c+n*y-a*u,t[s+3]=l*x-n*u-a*y-o*c,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,i,h){return this._x=t,this._y=s,this._z=i,this._w=h,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,h=t._y,e=t._z,r=t._order,n=Math.cos,a=Math.sin,o=n(i/2),l=n(h/2),u=n(e/2),y=a(i/2),c=a(h/2),x=a(e/2);switch(r){case"XYZ":this._x=y*l*u+o*c*x,this._y=o*c*u-y*l*x,this._z=o*l*x+y*c*u,this._w=o*l*u-y*c*x;break;case"YXZ":this._x=y*l*u+o*c*x,this._y=o*c*u-y*l*x,this._z=o*l*x-y*c*u,this._w=o*l*u+y*c*x;break;case"ZXY":this._x=y*l*u-o*c*x,this._y=o*c*u+y*l*x,this._z=o*l*x+y*c*u,this._w=o*l*u-y*c*x;break;case"ZYX":this._x=y*l*u-o*c*x,this._y=o*c*u+y*l*x,this._z=o*l*x-y*c*u,this._w=o*l*u+y*c*x;break;case"YZX":this._x=y*l*u+o*c*x,this._y=o*c*u+y*l*x,this._z=o*l*x-y*c*u,this._w=o*l*u-y*c*x;break;case"XZY":this._x=y*l*u-o*c*x,this._y=o*c*u-y*l*x,this._z=o*l*x+y*c*u,this._w=o*l*u+y*c*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return!1!==s&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const i=s/2,h=Math.sin(i);return this._x=t.x*h,this._y=t.y*h,this._z=t.z*h,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,i=s[0],h=s[4],e=s[8],r=s[1],n=s[5],a=s[9],o=s[2],l=s[6],u=s[10],y=i+n+u;if(y>0){const t=.5/Math.sqrt(y+1);this._w=.25/t,this._x=(l-a)*t,this._y=(e-o)*t,this._z=(r-h)*t}else if(i>n&&i>u){const t=2*Math.sqrt(1+i-n-u);this._w=(l-a)/t,this._x=.25*t,this._y=(h+r)/t,this._z=(e+o)/t}else if(n>u){const t=2*Math.sqrt(1+n-i-u);this._w=(e-o)/t,this._x=(h+r)/t,this._y=.25*t,this._z=(a+l)/t}else{const t=2*Math.sqrt(1+u-i-n);this._w=(r-h)/t,this._x=(e+o)/t,this._y=(a+l)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let i=t.dot(s)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(h(this.dot(t),-1,1)))}rotateTowards(t,s){const i=this.angleTo(t);if(0===i)return this;const h=Math.min(1,s/i);return this.slerp(t,h),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,s){return void 0!==s?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,s)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const i=t._x,h=t._y,e=t._z,r=t._w,n=s._x,a=s._y,o=s._z,l=s._w;return this._x=i*l+r*n+h*o-e*a,this._y=h*l+r*a+e*n-i*o,this._z=e*l+r*o+i*a-h*n,this._w=r*l-i*n-h*a-e*o,this._onChangeCallback(),this}slerp(t,s){if(0===s)return this;if(1===s)return this.copy(t);const i=this._x,h=this._y,e=this._z,r=this._w;let n=r*t._w+i*t._x+h*t._y+e*t._z;if(n<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,n=-n):this.copy(t),n>=1)return this._w=r,this._x=i,this._y=h,this._z=e,this;const a=1-n*n;if(a<=Number.EPSILON){const t=1-s;return this._w=t*r+s*this._w,this._x=t*i+s*this._x,this._y=t*h+s*this._y,this._z=t*e+s*this._z,this.normalize(),this._onChangeCallback(),this}const o=Math.sqrt(a),l=Math.atan2(o,n),u=Math.sin((1-s)*l)/o,y=Math.sin(s*l)/o;return this._w=r*u+this._w*y,this._x=i*u+this._x*y,this._y=h*u+this._y*y,this._z=e*u+this._z*y,this._onChangeCallback(),this}slerpQuaternions(t,s,i){this.copy(t).slerp(s,i)}random(){const t=Math.random(),s=Math.sqrt(1-t),i=Math.sqrt(t),h=2*Math.PI*Math.random(),e=2*Math.PI*Math.random();return this.set(s*Math.cos(h),i*Math.sin(e),i*Math.cos(e),s*Math.sin(h))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}e.prototype.isQuaternion=!0;class r{constructor(t=0,s=0,i=0){this.x=t,this.y=s,this.z=i}set(t,s,i){return void 0===i&&(i=this.z),this.x=t,this.y=s,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,s)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(a.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(a.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,i=this.y,h=this.z,e=t.elements;return this.x=e[0]*s+e[3]*i+e[6]*h,this.y=e[1]*s+e[4]*i+e[7]*h,this.z=e[2]*s+e[5]*i+e[8]*h,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,i=this.y,h=this.z,e=t.elements,r=1/(e[3]*s+e[7]*i+e[11]*h+e[15]);return this.x=(e[0]*s+e[4]*i+e[8]*h+e[12])*r,this.y=(e[1]*s+e[5]*i+e[9]*h+e[13])*r,this.z=(e[2]*s+e[6]*i+e[10]*h+e[14])*r,this}applyQuaternion(t){const s=this.x,i=this.y,h=this.z,e=t.x,r=t.y,n=t.z,a=t.w,o=a*s+r*h-n*i,l=a*i+n*s-e*h,u=a*h+e*i-r*s,y=-e*s-r*i-n*h;return this.x=o*a+y*-e+l*-n-u*-r,this.y=l*a+y*-r+u*-e-o*-n,this.z=u*a+y*-n+o*-r-l*-e,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,i=this.y,h=this.z,e=t.elements;return this.x=e[0]*s+e[4]*i+e[8]*h,this.y=e[1]*s+e[5]*i+e[9]*h,this.z=e[2]*s+e[6]*i+e[10]*h,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this}cross(t,s){return void 0!==s?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,s)):this.crossVectors(this,t)}crossVectors(t,s){const i=t.x,h=t.y,e=t.z,r=s.x,n=s.y,a=s.z;return this.x=h*a-e*n,this.y=e*r-i*a,this.z=i*n-h*r,this}projectOnVector(t){const s=t.lengthSq();if(0===s)return this.set(0,0,0);const i=t.dot(this)/s;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return n.copy(this).projectOnVector(t),this.sub(n)}reflect(t){return this.sub(n.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===s)return Math.PI/2;const i=this.dot(t)/s;return Math.acos(h(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y,h=this.z-t.z;return s*s+i*i+h*h}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,i){const h=Math.sin(s)*t;return this.x=h*Math.sin(i),this.y=Math.cos(s)*t,this.z=h*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,i){return this.x=t*Math.sin(s),this.y=i,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),h=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=i,this.z=h,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,4*s)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,3*s)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),s=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(s),this.y=i*Math.sin(s),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}r.prototype.isVector3=!0;const n=new r,a=new e;class o{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,s,i,h,e,r,n,a,o,l,u,y,c,x,m,M){const z=this.elements;return z[0]=t,z[4]=s,z[8]=i,z[12]=h,z[1]=e,z[5]=r,z[9]=n,z[13]=a,z[2]=o,z[6]=l,z[10]=u,z[14]=y,z[3]=c,z[7]=x,z[11]=m,z[15]=M,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new o).fromArray(this.elements)}copy(t){const s=this.elements,i=t.elements;return s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=i[3],s[4]=i[4],s[5]=i[5],s[6]=i[6],s[7]=i[7],s[8]=i[8],s[9]=i[9],s[10]=i[10],s[11]=i[11],s[12]=i[12],s[13]=i[13],s[14]=i[14],s[15]=i[15],this}copyPosition(t){const s=this.elements,i=t.elements;return s[12]=i[12],s[13]=i[13],s[14]=i[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,i){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,s,i){return this.set(t.x,s.x,i.x,0,t.y,s.y,i.y,0,t.z,s.z,i.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,i=t.elements,h=1/l.setFromMatrixColumn(t,0).length(),e=1/l.setFromMatrixColumn(t,1).length(),r=1/l.setFromMatrixColumn(t,2).length();return s[0]=i[0]*h,s[1]=i[1]*h,s[2]=i[2]*h,s[3]=0,s[4]=i[4]*e,s[5]=i[5]*e,s[6]=i[6]*e,s[7]=0,s[8]=i[8]*r,s[9]=i[9]*r,s[10]=i[10]*r,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const s=this.elements,i=t.x,h=t.y,e=t.z,r=Math.cos(i),n=Math.sin(i),a=Math.cos(h),o=Math.sin(h),l=Math.cos(e),u=Math.sin(e);if("XYZ"===t.order){const t=r*l,i=r*u,h=n*l,e=n*u;s[0]=a*l,s[4]=-a*u,s[8]=o,s[1]=i+h*o,s[5]=t-e*o,s[9]=-n*a,s[2]=e-t*o,s[6]=h+i*o,s[10]=r*a}else if("YXZ"===t.order){const t=a*l,i=a*u,h=o*l,e=o*u;s[0]=t+e*n,s[4]=h*n-i,s[8]=r*o,s[1]=r*u,s[5]=r*l,s[9]=-n,s[2]=i*n-h,s[6]=e+t*n,s[10]=r*a}else if("ZXY"===t.order){const t=a*l,i=a*u,h=o*l,e=o*u;s[0]=t-e*n,s[4]=-r*u,s[8]=h+i*n,s[1]=i+h*n,s[5]=r*l,s[9]=e-t*n,s[2]=-r*o,s[6]=n,s[10]=r*a}else if("ZYX"===t.order){const t=r*l,i=r*u,h=n*l,e=n*u;s[0]=a*l,s[4]=h*o-i,s[8]=t*o+e,s[1]=a*u,s[5]=e*o+t,s[9]=i*o-h,s[2]=-o,s[6]=n*a,s[10]=r*a}else if("YZX"===t.order){const t=r*a,i=r*o,h=n*a,e=n*o;s[0]=a*l,s[4]=e-t*u,s[8]=h*u+i,s[1]=u,s[5]=r*l,s[9]=-n*l,s[2]=-o*l,s[6]=i*u+h,s[10]=t-e*u}else if("XZY"===t.order){const t=r*a,i=r*o,h=n*a,e=n*o;s[0]=a*l,s[4]=-u,s[8]=o*l,s[1]=t*u+e,s[5]=r*l,s[9]=i*u-h,s[2]=h*u-i,s[6]=n*l,s[10]=e*u+t}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(y,t,c)}lookAt(t,s,i){const h=this.elements;return M.subVectors(t,s),0===M.lengthSq()&&(M.z=1),M.normalize(),x.crossVectors(i,M),0===x.lengthSq()&&(1===Math.abs(i.z)?M.x+=1e-4:M.z+=1e-4,M.normalize(),x.crossVectors(i,M)),x.normalize(),m.crossVectors(M,x),h[0]=x.x,h[4]=m.x,h[8]=M.x,h[1]=x.y,h[5]=m.y,h[9]=M.y,h[2]=x.z,h[6]=m.z,h[10]=M.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,s)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const i=t.elements,h=s.elements,e=this.elements,r=i[0],n=i[4],a=i[8],o=i[12],l=i[1],u=i[5],y=i[9],c=i[13],x=i[2],m=i[6],M=i[10],z=i[14],d=i[3],_=i[7],p=i[11],w=i[15],g=h[0],f=h[4],b=h[8],S=h[12],V=h[1],E=h[5],C=h[9],T=h[13],k=h[2],q=h[6],v=h[10],A=h[14],F=h[3],R=h[7],P=h[11],Q=h[15];return e[0]=r*g+n*V+a*k+o*F,e[4]=r*f+n*E+a*q+o*R,e[8]=r*b+n*C+a*v+o*P,e[12]=r*S+n*T+a*A+o*Q,e[1]=l*g+u*V+y*k+c*F,e[5]=l*f+u*E+y*q+c*R,e[9]=l*b+u*C+y*v+c*P,e[13]=l*S+u*T+y*A+c*Q,e[2]=x*g+m*V+M*k+z*F,e[6]=x*f+m*E+M*q+z*R,e[10]=x*b+m*C+M*v+z*P,e[14]=x*S+m*T+M*A+z*Q,e[3]=d*g+_*V+p*k+w*F,e[7]=d*f+_*E+p*q+w*R,e[11]=d*b+_*C+p*v+w*P,e[15]=d*S+_*T+p*A+w*Q,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],i=t[4],h=t[8],e=t[12],r=t[1],n=t[5],a=t[9],o=t[13],l=t[2],u=t[6],y=t[10],c=t[14];return t[3]*(+e*a*u-h*o*u-e*n*y+i*o*y+h*n*c-i*a*c)+t[7]*(+s*a*c-s*o*y+e*r*y-h*r*c+h*o*l-e*a*l)+t[11]*(+s*o*u-s*n*c-e*r*u+i*r*c+e*n*l-i*o*l)+t[15]*(-h*n*l-s*a*u+s*n*y+h*r*u-i*r*y+i*a*l)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,i){const h=this.elements;return t.isVector3?(h[12]=t.x,h[13]=t.y,h[14]=t.z):(h[12]=t,h[13]=s,h[14]=i),this}invert(){const t=this.elements,s=t[0],i=t[1],h=t[2],e=t[3],r=t[4],n=t[5],a=t[6],o=t[7],l=t[8],u=t[9],y=t[10],c=t[11],x=t[12],m=t[13],M=t[14],z=t[15],d=u*M*o-m*y*o+m*a*c-n*M*c-u*a*z+n*y*z,_=x*y*o-l*M*o-x*a*c+r*M*c+l*a*z-r*y*z,p=l*m*o-x*u*o+x*n*c-r*m*c-l*n*z+r*u*z,w=x*u*a-l*m*a-x*n*y+r*m*y+l*n*M-r*u*M,g=s*d+i*_+h*p+e*w;if(0===g)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const f=1/g;return t[0]=d*f,t[1]=(m*y*e-u*M*e-m*h*c+i*M*c+u*h*z-i*y*z)*f,t[2]=(n*M*e-m*a*e+m*h*o-i*M*o-n*h*z+i*a*z)*f,t[3]=(u*a*e-n*y*e-u*h*o+i*y*o+n*h*c-i*a*c)*f,t[4]=_*f,t[5]=(l*M*e-x*y*e+x*h*c-s*M*c-l*h*z+s*y*z)*f,t[6]=(x*a*e-r*M*e-x*h*o+s*M*o+r*h*z-s*a*z)*f,t[7]=(r*y*e-l*a*e+l*h*o-s*y*o-r*h*c+s*a*c)*f,t[8]=p*f,t[9]=(x*u*e-l*m*e-x*i*c+s*m*c+l*i*z-s*u*z)*f,t[10]=(r*m*e-x*n*e+x*i*o-s*m*o-r*i*z+s*n*z)*f,t[11]=(l*n*e-r*u*e-l*i*o+s*u*o+r*i*c-s*n*c)*f,t[12]=w*f,t[13]=(l*m*h-x*u*h+x*i*y-s*m*y-l*i*M+s*u*M)*f,t[14]=(x*n*h-r*m*h-x*i*a+s*m*a+r*i*M-s*n*M)*f,t[15]=(r*u*h-l*n*h+l*i*a-s*u*a-r*i*y+s*n*y)*f,this}scale(t){const s=this.elements,i=t.x,h=t.y,e=t.z;return s[0]*=i,s[4]*=h,s[8]*=e,s[1]*=i,s[5]*=h,s[9]*=e,s[2]*=i,s[6]*=h,s[10]*=e,s[3]*=i,s[7]*=h,s[11]*=e,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],h=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,i,h))}makeTranslation(t,s,i){return this.set(1,0,0,t,0,1,0,s,0,0,1,i,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,s,-i,0,0,i,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,0,i,0,0,1,0,0,-i,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s,-i,0,0,i,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const i=Math.cos(s),h=Math.sin(s),e=1-i,r=t.x,n=t.y,a=t.z,o=e*r,l=e*n;return this.set(o*r+i,o*n-h*a,o*a+h*n,0,o*n+h*a,l*n+i,l*a-h*r,0,o*a-h*n,l*a+h*r,e*a*a+i,0,0,0,0,1),this}makeScale(t,s,i){return this.set(t,0,0,0,0,s,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,s,i,h,e,r){return this.set(1,i,e,0,t,1,r,0,s,h,1,0,0,0,0,1),this}compose(t,s,i){const h=this.elements,e=s._x,r=s._y,n=s._z,a=s._w,o=e+e,l=r+r,u=n+n,y=e*o,c=e*l,x=e*u,m=r*l,M=r*u,z=n*u,d=a*o,_=a*l,p=a*u,w=i.x,g=i.y,f=i.z;return h[0]=(1-(m+z))*w,h[1]=(c+p)*w,h[2]=(x-_)*w,h[3]=0,h[4]=(c-p)*g,h[5]=(1-(y+z))*g,h[6]=(M+d)*g,h[7]=0,h[8]=(x+_)*f,h[9]=(M-d)*f,h[10]=(1-(y+m))*f,h[11]=0,h[12]=t.x,h[13]=t.y,h[14]=t.z,h[15]=1,this}decompose(t,s,i){const h=this.elements;let e=l.set(h[0],h[1],h[2]).length();const r=l.set(h[4],h[5],h[6]).length(),n=l.set(h[8],h[9],h[10]).length();this.determinant()<0&&(e=-e),t.x=h[12],t.y=h[13],t.z=h[14],u.copy(this);const a=1/e,o=1/r,y=1/n;return u.elements[0]*=a,u.elements[1]*=a,u.elements[2]*=a,u.elements[4]*=o,u.elements[5]*=o,u.elements[6]*=o,u.elements[8]*=y,u.elements[9]*=y,u.elements[10]*=y,s.setFromRotationMatrix(u),i.x=e,i.y=r,i.z=n,this}makePerspective(t,s,i,h,e,r){void 0===r&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const n=this.elements,a=2*e/(s-t),o=2*e/(i-h),l=(s+t)/(s-t),u=(i+h)/(i-h),y=-(r+e)/(r-e),c=-2*r*e/(r-e);return n[0]=a,n[4]=0,n[8]=l,n[12]=0,n[1]=0,n[5]=o,n[9]=u,n[13]=0,n[2]=0,n[6]=0,n[10]=y,n[14]=c,n[3]=0,n[7]=0,n[11]=-1,n[15]=0,this}makeOrthographic(t,s,i,h,e,r){const n=this.elements,a=1/(s-t),o=1/(i-h),l=1/(r-e),u=(s+t)*a,y=(i+h)*o,c=(r+e)*l;return n[0]=2*a,n[4]=0,n[8]=0,n[12]=-u,n[1]=0,n[5]=2*o,n[9]=0,n[13]=-y,n[2]=0,n[6]=0,n[10]=-2*l,n[14]=-c,n[3]=0,n[7]=0,n[11]=0,n[15]=1,this}equals(t){const s=this.elements,i=t.elements;for(let t=0;t<16;t++)if(s[t]!==i[t])return!1;return!0}fromArray(t,s=0){for(let i=0;i<16;i++)this.elements[i]=t[i+s];return this}toArray(t=[],s=0){const i=this.elements;return t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t[s+9]=i[9],t[s+10]=i[10],t[s+11]=i[11],t[s+12]=i[12],t[s+13]=i[13],t[s+14]=i[14],t[s+15]=i[15],t}}o.prototype.isMatrix4=!0;const l=new r,u=new o,y=new r(0,0,0),c=new r(1,1,1),x=new r,m=new r,M=new r;class z{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,s,i,h,e,r,n,a,o){const l=this.elements;return l[0]=t,l[1]=h,l[2]=n,l[3]=s,l[4]=e,l[5]=a,l[6]=i,l[7]=r,l[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const s=this.elements,i=t.elements;return s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=i[3],s[4]=i[4],s[5]=i[5],s[6]=i[6],s[7]=i[7],s[8]=i[8],this}extractBasis(t,s,i){return t.setFromMatrix3Column(this,0),s.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const s=t.elements;return this.set(s[0],s[4],s[8],s[1],s[5],s[9],s[2],s[6],s[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const i=t.elements,h=s.elements,e=this.elements,r=i[0],n=i[3],a=i[6],o=i[1],l=i[4],u=i[7],y=i[2],c=i[5],x=i[8],m=h[0],M=h[3],z=h[6],d=h[1],_=h[4],p=h[7],w=h[2],g=h[5],f=h[8];return e[0]=r*m+n*d+a*w,e[3]=r*M+n*_+a*g,e[6]=r*z+n*p+a*f,e[1]=o*m+l*d+u*w,e[4]=o*M+l*_+u*g,e[7]=o*z+l*p+u*f,e[2]=y*m+c*d+x*w,e[5]=y*M+c*_+x*g,e[8]=y*z+c*p+x*f,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[3]*=t,s[6]*=t,s[1]*=t,s[4]*=t,s[7]*=t,s[2]*=t,s[5]*=t,s[8]*=t,this}determinant(){const t=this.elements,s=t[0],i=t[1],h=t[2],e=t[3],r=t[4],n=t[5],a=t[6],o=t[7],l=t[8];return s*r*l-s*n*o-i*e*l+i*n*a+h*e*o-h*r*a}invert(){const t=this.elements,s=t[0],i=t[1],h=t[2],e=t[3],r=t[4],n=t[5],a=t[6],o=t[7],l=t[8],u=l*r-n*o,y=n*a-l*e,c=o*e-r*a,x=s*u+i*y+h*c;if(0===x)return this.set(0,0,0,0,0,0,0,0,0);const m=1/x;return t[0]=u*m,t[1]=(h*o-l*i)*m,t[2]=(n*i-h*r)*m,t[3]=y*m,t[4]=(l*s-h*a)*m,t[5]=(h*e-n*s)*m,t[6]=c*m,t[7]=(i*a-o*s)*m,t[8]=(r*s-i*e)*m,this}transpose(){let t;const s=this.elements;return t=s[1],s[1]=s[3],s[3]=t,t=s[2],s[2]=s[6],s[6]=t,t=s[5],s[5]=s[7],s[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const s=this.elements;return t[0]=s[0],t[1]=s[3],t[2]=s[6],t[3]=s[1],t[4]=s[4],t[5]=s[7],t[6]=s[2],t[7]=s[5],t[8]=s[8],this}setUvTransform(t,s,i,h,e,r,n){const a=Math.cos(e),o=Math.sin(e);return this.set(i*a,i*o,-i*(a*r+o*n)+r+t,-h*o,h*a,-h*(-o*r+a*n)+n+s,0,0,1),this}scale(t,s){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=s,i[4]*=s,i[7]*=s,this}rotate(t){const s=Math.cos(t),i=Math.sin(t),h=this.elements,e=h[0],r=h[3],n=h[6],a=h[1],o=h[4],l=h[7];return h[0]=s*e+i*a,h[3]=s*r+i*o,h[6]=s*n+i*l,h[1]=-i*e+s*a,h[4]=-i*r+s*o,h[7]=-i*n+s*l,this}translate(t,s){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=s*i[2],i[4]+=s*i[5],i[7]+=s*i[8],this}equals(t){const s=this.elements,i=t.elements;for(let t=0;t<9;t++)if(s[t]!==i[t])return!1;return!0}fromArray(t,s=0){for(let i=0;i<9;i++)this.elements[i]=t[i+s];return this}toArray(t=[],s=0){const i=this.elements;return t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}z.prototype.isMatrix3=!0;class d{constructor(t=0,s=0,i=0,h=1){this.x=t,this.y=s,this.z=i,this.w=h}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,s,i,h){return this.x=t,this.y=s,this.z=i,this.w=h,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;case 3:this.w=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this.w=t.w+s.w,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this.w+=t.w*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this.w=t.w-s.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const s=this.x,i=this.y,h=this.z,e=this.w,r=t.elements;return this.x=r[0]*s+r[4]*i+r[8]*h+r[12]*e,this.y=r[1]*s+r[5]*i+r[9]*h+r[13]*e,this.z=r[2]*s+r[6]*i+r[10]*h+r[14]*e,this.w=r[3]*s+r[7]*i+r[11]*h+r[15]*e,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const s=Math.sqrt(1-t.w*t.w);return s<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/s,this.y=t.y/s,this.z=t.z/s),this}setAxisAngleFromRotationMatrix(t){let s,i,h,e;const r=.01,n=.1,a=t.elements,o=a[0],l=a[4],u=a[8],y=a[1],c=a[5],x=a[9],m=a[2],M=a[6],z=a[10];if(Math.abs(l-y)<r&&Math.abs(u-m)<r&&Math.abs(x-M)<r){if(Math.abs(l+y)<n&&Math.abs(u+m)<n&&Math.abs(x+M)<n&&Math.abs(o+c+z-3)<n)return this.set(1,0,0,0),this;s=Math.PI;const t=(o+1)/2,a=(c+1)/2,d=(z+1)/2,_=(l+y)/4,p=(u+m)/4,w=(x+M)/4;return t>a&&t>d?t<r?(i=0,h=.707106781,e=.707106781):(i=Math.sqrt(t),h=_/i,e=p/i):a>d?a<r?(i=.707106781,h=0,e=.707106781):(h=Math.sqrt(a),i=_/h,e=w/h):d<r?(i=.707106781,h=.707106781,e=0):(e=Math.sqrt(d),i=p/e,h=w/e),this.set(i,h,e,s),this}let d=Math.sqrt((M-x)*(M-x)+(u-m)*(u-m)+(y-l)*(y-l));return Math.abs(d)<.001&&(d=1),this.x=(M-x)/d,this.y=(u-m)/d,this.z=(y-l)/d,this.w=Math.acos((o+c+z-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this.w=Math.max(t.w,Math.min(s.w,this.w)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this.w=Math.max(t,Math.min(s,this.w)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this.w+=(t.w-this.w)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this.w=t.w+(s.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this.w=t[s+3],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t[s+3]=this.w,t}fromBufferAttribute(t,s,i){return void 0!==i&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this.w=t.getW(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}d.prototype.isVector4=!0;class _{constructor(t=0,s=0){this.x=t,this.y=s}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,s){return this.x=t,this.y=s,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const s=this.x,i=this.y,h=t.elements;return this.x=h[0]*s+h[3]*i+h[6],this.y=h[1]*s+h[4]*i+h[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y;return s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t}fromBufferAttribute(t,s,i){return void 0!==i&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this}rotateAround(t,s){const i=Math.cos(s),h=Math.sin(s),e=this.x-t.x,r=this.y-t.y;return this.x=e*i-r*h+t.x,this.y=e*h+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}_.prototype.isVector2=!0;const{Matrix4:p,Matrix3:w,Vector4:g,Vector3:f,Vector2:b,Quaternion:S}=s;function V(t){return`${t.name}(\n\t${Object.getOwnPropertyNames(t.prototype).join("\n\t")}\n)`}b.prototype.toString=function(){return`Vector2(${this.x}, ${this.y})`},b.prototype.ToArray=function(){return[this.x,this.y]},f.prototype.toString=function(){return`Vector3(${this.x}, ${this.y}, ${this.z})`},f.prototype.ToArray=function(){return[this.x,this.y,this.z]},g.prototype.toString=function(){return`Vector4(${this.x}, ${this.y}, ${this.z}, ${this.w})`},g.prototype.ToArray=function(){return[this.x,this.y,this.z,this.w]},w.prototype.toString=function(){const t=this.elements;let s="Matrix3(\n";for(let i=0;i<3;i++){for(let h=0;h<3;h++)s+="\t"+t[3*i+h];s+="\n"}return s+=")",s},w.prototype.ToArray=function(){return[...this.elements]},p.prototype.toString=function(){const t=this.elements;let s="Matrix4(\n";for(let i=0;i<4;i++){for(let h=0;h<4;h++)s+="\t"+t[4*i+h];s+="\n"}return s+=")",s},p.prototype.ToArray=function(){return[...this.elements]},p.prototype.Mul=function(t){return this.multiplyMatrices(t,this)},p.prototype.Multiply=p.prototype.Mul,S.prototype.toString=function(){return`Vector4(${this._x}, ${this._y}, ${this._z}, ${this._w})`},S.prototype.ToArray=function(){return[this._x,this._y,this._z,this._w]},b.enumMethods=function(){return V(this)},f.enumMethods=function(){return V(this)},g.enumMethods=function(){return V(this)},w.enumMethods=function(){return V(this)},p.enumMethods=function(){return V(this)},S.enumMethods=function(){return V(this)},globalThis.Matrix4=p,globalThis.Matrix3=w,globalThis.Vector4=g,globalThis.Vector3=f,globalThis.Vector2=b,globalThis.Quaternion=S})();